SET @var="CREATE SCHEMA foomine";
EXECUTE @var CONCURRENT;
# YEs, this is a hack. Remember that foomine may or may not be around since
# it happens at the same time.
select sleep(2);
show schemas LIKE "foomine";
SET @var="DROP SCHEMA foomine";
EXECUTE @var CONCURRENT;

# Now lets see what the processlist shows.
SET @sleep="SELECT SLEEP(3)";
EXECUTE @sleep CONCURRENT;
SELECT USER,INFO FROM DATA_DICTIONARY.PROCESSLIST;

# Wait till we know the above is done (this will be replaced with broadcast() in the future)
EXECUTE @sleep;

# Check that a concurrent session cannot create one of itself, but can call
# execute.
SET @var="EXECUTE \"SELECT SLEEP(3)\"";
EXECUTE @var CONCURRENT;
SELECT USER,INFO FROM DATA_DICTIONARY.PROCESSLIST;

# Wait till everything closes out
EXECUTE @sleep;
SET @var="EXECUTE \"SELECT SLEEP(3)\" CONCURRENT";
EXECUTE @var CONCURRENT;
SELECT USER,INFO FROM DATA_DICTIONARY.PROCESSLIST;


# Test multiple statements

SET @var="CREATE SCHEMA d; CREATE SCHEMA e;";
EXECUTE @var CONCURRENT;

# Wait for a second...
EXECUTE @sleep;
show schemas LIKE "d";
show schemas LIKE "e";
DROP SCHEMA d;
DROP SCHEMA e;


# We are now going to make sure that data is actually committed.
CREATE TABLE foo (a serial);

SET @var="INSERT INTO foo VALUES(); INSERT INTO foo VALUES ()";
EXECUTE @var CONCURRENT;
EXECUTE @sleep;
SELECT * FROM foo;

SET @var="SAVEPOINT mine; INSERT INTO foo VALUES(); INSERT INTO foo VALUES ()";
EXECUTE @var CONCURRENT;
EXECUTE @sleep;
SELECT * FROM foo;

SET @var="SAVEPOINT mine; INSERT INTO foo VALUES(); INSERT INTO foo VALUES (); RELEASE SAVEPOINT mine";
EXECUTE @var CONCURRENT;
EXECUTE @sleep;
SELECT * FROM foo;

SET @var="SAVEPOINT mine; INSERT INTO foo VALUES (); INSERT INTO foo VALUES (); ROLLBACK TO SAVEPOINT mine";
EXECUTE @var CONCURRENT;
EXECUTE @sleep;
SELECT * FROM foo;

DROP TABLE foo;

