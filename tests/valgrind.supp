#
# Suppress some common (not fatal) errors in system libraries found by valgrind
#

#
# Pthread doesn't free all thread specific memory before program exists
#
{
   pthread allocate_tls memory loss
   Memcheck:Leak
   fun:calloc
   fun:_dl_allocate_tls
   fun:allocate_stack
   fun:pthread_create*
}

{
   pthread allocate_tls memory loss
   Memcheck:Leak
   fun:calloc
   fun:_dl_allocate_tls
   fun:pthread_create*

}

{
   pthread_exit memory loss 1
   Memcheck:Leak
   fun:malloc
   fun:_dl_new_object
   fun:_dl_map_object_from_fd
}

{
   pthread_exit memory loss 2
   Memcheck:Leak
   fun:malloc
   fun:_dl_map_object
   fun:dl_open_worker
}

{
   pthread_exit memory loss 3
   Memcheck:Leak
   fun:malloc
   fun:_dl_map_object_deps
   fun:dl_open_worker
}

{
   pthread_exit memory loss 4
   Memcheck:Leak
   fun:calloc
   fun:_dl_check_map_versions
   fun:dl_open_worker
}

{
   pthread_exit memory loss 5
   Memcheck:Leak
   fun:calloc
   fun:_dl_new_object
   fun:_dl_map_object_from_fd
}

{
   pthread allocate_dtv memory loss
   Memcheck:Leak
   fun:calloc
   fun:allocate_dtv
   fun:_dl_allocate_tls_storage
   fun:__GI__dl_allocate_tls
   fun:pthread_create
}

{
   pthread allocate_dtv memory loss second
   Memcheck:Leak
   fun:calloc
   fun:allocate_dtv
   fun:_dl_allocate_tls
   fun:pthread_create*
}

{
   pthread memalign memory loss
   Memcheck:Leak
   fun:memalign
   fun:_dl_allocate_tls_storage
   fun:__GI__dl_allocate_tls
   fun:pthread_create
}

{
   pthread pthread_key_create
   Memcheck:Leak
   fun:malloc
   fun:*
   fun:*
   fun:pthread_key_create
   fun:my_thread_global_init
}

{
   pthread strstr uninit
   Memcheck:Cond
   fun:strstr
   obj:/lib/tls/libpthread.so.*
   obj:/lib/tls/libpthread.so.*
   fun:call_init
   fun:_dl_init
   obj:/lib/ld-*.so
}

{
   pthread strstr uninit
   Memcheck:Cond
   fun:strstr
   obj:/lib/tls/libpthread.so.*
   obj:/lib/tls/libpthread.so.*
   fun:call_init
   fun:_dl_init
   obj:/lib/ld-*.so
}

{  
   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)
   Memcheck:Cond
   fun:strlen
   fun:_dl_init_paths
   fun:dl_main
   fun:_dl_sysdep_start
}

{
   pthread errno
   Memcheck:Leak
   fun:calloc
   fun:_dlerror_run
   fun:dlsym
   fun:__errno_location
}


#
# Warnings in libz becasue it works with aligned memory(?)
#

{
   libz tr_flush_block
   Memcheck:Cond
   fun:_tr_flush_block
   fun:deflate_slow
   fun:deflate
   fun:do_flush
   fun:gzclose
}

{
   libz tr_flush_block2
   Memcheck:Cond
   fun:_tr_flush_block
   fun:deflate_slow
   fun:deflate
   fun:compress2
}

{
   libz longest_match
   Memcheck:Cond
   fun:longest_match
   fun:deflate_slow
   fun:deflate
   fun:do_flush
}

{
   libz longest_match2
   Memcheck:Cond
   fun:longest_match
   fun:deflate_slow
   fun:deflate
   fun:compress2
}

{
   libz longest_match 3
   Memcheck:Cond
   fun:longest_match
   fun:deflate_slow
   fun:deflate
   fun:gzclose
}

{
   libz longest_match 4 
   Memcheck:Cond
   fun:longest_match
   fun:deflate_slow
   fun:deflate
   fun:gzflush
}

{
   libz longest_match3
   Memcheck:Cond
   fun:longest_match
   fun:deflate_slow
   fun:deflate
   fun:azflush
}

{
   libz longest_match3
   Memcheck:Cond
   fun:longest_match
   fun:deflate_slow
   fun:deflate
   fun:azclose
}

{
   libz deflate
   Memcheck:Cond
   obj:*/libz.so.*
   obj:*/libz.so.*
   fun:deflate
   fun:compress2
}

{
   libz deflate2
   Memcheck:Cond
   obj:*/libz.so.*
   obj:*/libz.so.*
   fun:deflate
   obj:*/libz.so.*
   fun:gzflush
}

{
   libz deflate3
   Memcheck:Cond
   obj:*/libz.so.*
   obj:*/libz.so.*
   fun:deflate
   fun:do_flush
}

#
# Warning from my_thread_init becasue mysqld dies before kill thread exists
#

{
   my_thread_init kill thread memory loss second
   Memcheck:Leak
   fun:calloc
   fun:my_thread_init
   fun:kill_server_thread
}


# Red Hat AS 4 32 bit
{
   dl_relocate_object
   Memcheck:Cond
   fun:_dl_relocate_object
}

#
# Warning from my_thread_init becasue mysqld dies before kill thread exists
#

{
   my_thread_init kill thread memory loss second
   Memcheck:Leak
   fun:calloc
   fun:my_thread_init
   fun:kill_server_thread
}

#
# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.
#

{
   _dl_start invalid write8
   Memcheck:Addr8
   fun:_dl_start
}

{
   _dl_start invalid write4
   Memcheck:Addr4
   fun:_dl_start
}

{
   _dl_start/_dl_setup_hash invalid read8
   Memcheck:Addr8
   fun:_dl_setup_hash
   fun:_dl_start
}

{
   _dl_sysdep_start invalid write8
   Memcheck:Addr8
   fun:_dl_sysdep_start
}

{
   _dl_init invalid write8
   Memcheck:Addr8
   fun:_dl_init
}

{
   _dl_init invalid write4
   Memcheck:Addr4
   fun:_dl_init
}

{
   _dl_init/_dl_init invalid read8
   Memcheck:Addr8
   fun:_dl_debug_initialize
   fun:_dl_init
}

{
   _dl_init/_dl_debug_state invalid read8
   Memcheck:Addr8
   fun:_dl_debug_state
   fun:_dl_init
}

{
   init invalid write8
   Memcheck:Addr8
   fun:init
}

{
   fixup invalid write8
   Memcheck:Addr8
   fun:fixup
}

{
   fixup/_dl_lookup_versioned_symbol invalid read8
   Memcheck:Addr8
   fun:_dl_lookup_versioned_symbol
   fun:fixup
}

{
   _dl_runtime_resolve invalid read8
   Memcheck:Addr8
   fun:_dl_runtime_resolve
}

{
   __libc_start_main invalid write8
   Memcheck:Addr8
   fun:__libc_start_main
}

{
   __libc_start_main/__sigjmp_save invalid write4
   Memcheck:Addr4
   fun:__sigjmp_save
   fun:__libc_start_main
}

#
# These seem to be libc threading stuff, not related to MySQL code (allocations
# during pthread_exit()). Googling shows other projects also using these
# suppressions.
#
# Note that these all stem from pthread_exit() deeper in the call stack, but
# Valgrind only allows the top four calls in the suppressions.
#

{
   libc pthread_exit 1
   Memcheck:Leak
   fun:malloc
   fun:_dl_new_object
   fun:_dl_map_object_from_fd
   fun:_dl_map_object
}

{
   libc pthread_exit 2
   Memcheck:Leak
   fun:malloc
   fun:_dl_map_object
   fun:dl_open_worker
   fun:_dl_catch_error
}

{
   libc pthread_exit 3
   Memcheck:Leak
   fun:malloc
   fun:_dl_map_object_deps
   fun:dl_open_worker
   fun:_dl_catch_error
}

{
   libc pthread_exit 4
   Memcheck:Leak
   fun:calloc
   fun:_dl_check_map_versions
   fun:dl_open_worker
   fun:_dl_catch_error
}

{
   libc pthread_exit 5
   Memcheck:Leak
   fun:calloc
   fun:_dl_new_object
   fun:_dl_map_object_from_fd
   fun:_dl_map_object
}

{
   libc pthread_exit 6
   Memcheck:Leak
   fun:malloc
   fun:_dl_map_object
   fun:openaux
   fun:_dl_catch_error 
}

{
   libc pthread_exit 7
   Memcheck:Leak
   fun:malloc
   fun:dl_open_worker
   fun:_dl_catch_error
   fun:_dl_open
}

#
# This is seen internally in the system libraries on 64-bit RHAS3.
#

{
   __lll_mutex_unlock_wake uninitialized
   Memcheck:Param
   futex(utime)
   fun:__lll_mutex_unlock_wake
}

#
# BUG#19940: NDB sends uninitialized parts of field buffers across the wire.
# This is "works as designed"; the uninitialized part is not used at the
# other end (but Valgrind cannot see this).
#
{
   bug19940
   Memcheck:Param
   socketcall.sendto(msg)
   fun:send
   fun:_ZN15TCP_Transporter6doSendEv
   fun:_ZN19TransporterRegistry11performSendEv
   fun:_ZN19TransporterRegistry14forceSendCheckEi
}
# Warning when printing stack trace (to suppress some not needed warnings)
#

{
   vprintf on stacktrace
   Memcheck:Cond
   fun:vfprintf
   fun:uffered_vfprintf
   fun:vfprintf
   fun:fprintf
   fun:print_stacktrace
}

#
# Safe warnings, that may happen because of thread scheduling
#

{
   dbug initialization by kill_server
   Memcheck:Leak
   fun:malloc
   fun:DbugMalloc
   fun:code_state
   fun:_db_enter_
   fun:kill_server
}

#
# Warning caused by small memory leak in threaded dlopen
#

{
   dlopen threaded memory leak
   Memcheck:Leak
   fun:calloc
   obj:*/libdl-*.so
   fun:dlopen*
}

#
# On some systems the above leak happens at dlclose (SuSE 10.1 64 bit on
# blade13)
#

{
   dlclose threaded memory leak
   Memcheck:Leak
   fun:calloc
   obj:*/libdl-*.so
   fun:dlclose*
}


#
# Start of Google Protobuffer suppressions.  GPB does static initialization
# of default message Descriptors and file descriptor classes, which produce
# bogus still reachable errors in memcheck.
#

{
   static initialization proto1
   Memcheck:Leak
   fun:_Znwm
   fun:_ZN8drizzled7message56protobuf_BuildDesc_table_2eproto_AssignGlobalDescriptorsEPKN6google8protobuf14FileDescriptorE
   fun:_ZN6google8protobuf17DescriptorBuilder9BuildFileERKNS0_19FileDescriptorProtoEPFvPKNS0_14FileDescriptorEE
   fun:_ZN6google8protobuf14DescriptorPool26InternalBuildGeneratedFileEPKviPFvPKNS0_14FileDescriptorEE
   fun:_ZN8drizzled7message32protobuf_BuildDesc_table_2eprotoEv
   fun:_ZN8drizzled7message41StaticDescriptorInitializer_table_2eprotoC1Ev
   fun:_Z41__static_initialization_and_destruction_0ii
   fun:_GLOBAL__I_table.pb.cc
   obj:/*/drizzled
   obj:/*/drizzled
   obj:*
   fun:__libc_csu_init
   fun:(below main)
}
{
   static initialization proto2
   Memcheck:Leak
   fun:_Znwm
   fun:_ZN6google8protobuf81protobuf_BuildDesc_google_2fprotobuf_2fdescriptor_2eproto_AssignGlobalDescriptorsEPKNS0_14FileDescriptorE
   fun:_ZN6google8protobuf17DescriptorBuilder9BuildFileERKNS0_19FileDescriptorProtoEPFvPKNS0_14FileDescriptorEE
   fun:_ZN6google8protobuf14DescriptorPool26InternalBuildGeneratedFileEPKviPFvPKNS0_14FileDescriptorEE
   obj:/*libprotobuf.so*
   obj:/*libprotobuf.so*
   obj:/*libprotobuf.so*
   obj:*
   fun:_dl_init
   obj:/lib/ld-*.so
   obj:*
   obj:*
   obj:*
   obj:*
   obj:*
   obj:*
}
{
   static initialization proto3
   Memcheck:Leak
   fun:_Znwm
   fun:_ZN8drizzled7message62protobuf_BuildDesc_transaction_2eproto_AssignGlobalDescriptorsEPKN6google8protobuf14FileDescriptorE
   fun:_ZN6google8protobuf17DescriptorBuilder9BuildFileERKNS0_19FileDescriptorProtoEPFvPKNS0_14FileDescriptorEE
   fun:_ZN6google8protobuf14DescriptorPool26InternalBuildGeneratedFileEPKviPFvPKNS0_14FileDescriptorEE
   fun:_ZN8drizzled7message38protobuf_BuildDesc_transaction_2eprotoEv
   fun:_ZN8drizzled7message47StaticDescriptorInitializer_transaction_2eprotoC1Ev
   fun:_Z41__static_initialization_and_destruction_0ii
   fun:_GLOBAL__I_transaction.pb.cc
   obj:/*/drizzled
   obj:/*/drizzled
   obj:*
   fun:__libc_csu_init
   fun:(below main)
}
{
   static initialization proto4
   Memcheck:Leak
   fun:_Znwm
   fun:_ZN8drizzled7message57protobuf_BuildDesc_schema_2eproto_AssignGlobalDescriptorsEPKN6google8protobuf14FileDescriptorE
   fun:_ZN6google8protobuf17DescriptorBuilder9BuildFileERKNS0_19FileDescriptorProtoEPFvPKNS0_14FileDescriptorEE
   fun:_ZN6google8protobuf14DescriptorPool26InternalBuildGeneratedFileEPKviPFvPKNS0_14FileDescriptorEE
   fun:_ZN8drizzled7message33protobuf_BuildDesc_schema_2eprotoEv
   fun:_ZN8drizzled7message42StaticDescriptorInitializer_schema_2eprotoC1Ev
   fun:_Z41__static_initialization_and_destruction_0ii
   fun:_GLOBAL__I_schema.pb.cc
   obj:/*/drizzled
   obj:/*/drizzled
   obj:*
   fun:__libc_csu_init
   fun:(below main)
}
{
   static initialization proto5
   Memcheck:Leak
   fun:_Znwm
   fun:_ZN8drizzled7message62protobuf_BuildDesc_transaction_2eproto_AssignGlobalDescriptorsEPKN6google8protobuf14FileDescriptorE
   fun:_ZN6google8protobuf17DescriptorBuilder9BuildFileERKNS0_19FileDescriptorProtoEPFvPKNS0_14FileDescriptorEE
   fun:_ZN6google8protobuf14DescriptorPool26InternalBuildGeneratedFileEPKviPFvPKNS0_14FileDescriptorEE
   fun:_ZN8drizzled7message38protobuf_BuildDesc_transaction_2eprotoEv
   fun:_ZN8drizzled7message47StaticDescriptorInitializer_transaction_2eprotoC1Ev
   fun:_Z41__static_initialization_and_destruction_0ii
   fun:_GLOBAL__I_transaction.pb.cc
   obj:/*/drizzled
   obj:/*/drizzled
   obj:*
   fun:__libc_csu_init
   fun:(below main)
}

{
  Bad InnoDB rw_lock_x_lock_func evil evil
   Memcheck:Cond
   fun:rw_lock_x_lock_func
}

#
# Innodb initialize two main memory areas in static space: thr_local_hash and mem_comm_pool.
#
# About 5M of allocated bytes are left in a reachable state upon shutdown. We suppress this
# false positive here...
#

{
   thr_local_hash static initialization
   Memcheck:Leak
   fun:malloc
   fun:mem_area_alloc
   fun:mem_heap_create_block
   fun:mem_heap_create_func
   fun:mem_alloc_func
   fun:hash0_create
   fun:thr_local_init
   fun:srv_general_init
   fun:srv_boot
   fun:innobase_start_or_create_for_mysql
   fun:_ZL13innobase_initR14PluginRegistry
   fun:_ZL17plugin_initializeP13st_plugin_int
   fun:_Z11plugin_initPiPPci
   fun:_ZL22init_server_componentsv
   fun:main
}

{
   mem_comm_pool static initialization
   Memcheck:Leak
   fun:malloc
   fun:ut_malloc_low
   fun:ut_malloc
   fun:mem_pool_create
   fun:mem_init
   fun:srv_general_init
   fun:srv_boot
   fun:innobase_start_or_create_for_mysql
   fun:_ZL13innobase_initR14PluginRegistry
   fun:_ZL17plugin_initializeP13st_plugin_int
   fun:_Z11plugin_initPiPPci
   fun:_ZL22init_server_componentsv
   fun:main
}

#
# InnoDB uses a yacc-based lexer which holds its yyval variable in
# static space. This variable is of type pointer to que_t.  This
# static variable is realloc()'d when a larger number of que_t's (AST nodes)
# is needed.
#
# This static allocation results in false positives for reachable
# memory at server (or actually plugin) shutdown.  Therefore, we correct
# with the following suppressions.
#

{
   InnoDB parser static allocation 1
   Memcheck:Leak
   fun:realloc
   fun:ut_realloc
   fun:string_append
   fun:yylex
   fun:yyparse
   fun:pars_sql
}

{
   InnoDB Parser allocation 2
   Memcheck:Leak
   fun:realloc
   fun:string_append
   fun:yylex
   fun:yyparse
   fun:pars_sql
}


#
# LIBC's nss_parse_service_list() and tsearch(), which are used by various syscalls
# like getpwnam() malloc's some pointers in static space. We suppress
# this false positive here...
#

{
   nss_parse_service_list static allocation
   Memcheck:Leak
   fun:malloc
   fun:nss_parse_service_list
   fun:__nss_database_lookup
   obj:*
   obj:*
   fun:getpwnam_r*
   fun:getpwnam
   fun:_ZL10check_userPKc
   fun:main
}

{
   tsearch static allocation
   Memcheck:Leak
   fun:malloc
   fun:tsearch
   fun:__nss_lookup_function
   obj:*
   obj:*
   fun:getpwnam_r*
   fun:getpwnam
   fun:_ZL10check_userPKc
   fun:main
}


#
# PCRE initializes compiled regular expression objects into
# static space, and therefore show up as memory leaks.  These
# are false positives and are handled by the PCRE library. There
# is no way to manually free pcre_compile()d returned pointers.
#

{
   pcre static initialization correction
   Memcheck:Leak
   fun:malloc
   fun:pcre_compile2
   fun:_ZN8drizzled14TemporalFormatC1EPKc
   fun:_Z21init_temporal_formatsv
   fun:_ZL21init_common_variablesPKciPPcPS0_
   fun:main
}

{
   Leak inside of libcurl. Nothing we can really do about it.
   Memcheck:Leak
   fun:realloc
   fun:CRYPTO_realloc
   fun:lh_insert
}

{
   Another leak in libcrypto
   Memcheck:Leak
   fun:malloc
   fun:CRYPTO_malloc
   fun:lh_new
}


{
   A leak in pcre
   Memcheck:Leak
   fun:malloc
   fun:pcre_compile2
}

{
   nss leak
   Memcheck:Leak
   fun:malloc
   obj:/lib/libc-2.9.so
   fun:__nss_database_lookup
}
